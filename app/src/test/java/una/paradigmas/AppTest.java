package una.paradigmas;

import org.junit.Test;

import una.paradigmas.ast.AstBuilder;
// import una.paradigmas.ast.AstPrintVisitor;
import una.paradigmas.ast.ExpressoLexer;
import una.paradigmas.ast.ExpressoParser;
import una.paradigmas.ast.JavaCodeGenerator;
import una.paradigmas.ast.Typer;
import una.paradigmas.node.Program;

import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CharStreams;
import org.antlr.v4.runtime.CommonTokenStream;

 /**
 * Proyecto: Expresso - Transpilador de lenguaje Expresso a Java
 * Curso: [EIF400-II-2025] Paradigmas de Programacion
 * Universidad Nacional de Costa Rica
 * 
 * Autores:
 * - Kendall Miso Chinchilla Araya  -   119310542
 * - Ignacio Serrano Gonzalez       -   402600631
 * - Minor Brenes Aguilar           -   116730106
 * - Pablo Chavarria Alvarez        -   117810573
 * 
 * Codigo de grupo: 02-1PM
 * 
 * This source file was generated by the Gradle 'init' task
 * 
 * Nota: Este codigo fue generado parcialmente con asistencia de IA
 * y posteriormente modificado, adaptado y validado por el equipo
 * de desarrollo para cumplir con los requerimientos especificos
 * del proyecto.
 */

 public class AppTest {
    
    private void testExpressoProgram(String input, String className) {
        CharStream charStream = CharStreams.fromString(input);
        ExpressoLexer lexer = new ExpressoLexer(charStream);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        ExpressoParser parser = new ExpressoParser(tokens);

        AstBuilder builder = new AstBuilder();
        Program ast = builder.visitProgram(parser.program());

        // AstPrintVisitor printer = new AstPrintVisitor();
        // printer.visitProgram(ast);

        Typer typer = new Typer(ast.symbolTable(), ast.contextMap());
        typer.typeCheck(ast);
        System.out.println(typer.toString());

        String art = switch(className){
            case "Jupyter" ->
            """
                ~+

                *       +
          '                  |
      ()       ,="``"=.    - o -
              /        \\     |
         *   |   =._    |
              \\     `=./          '
           .   '=.__.='          *
  +                         +
       O      *        '       .
""";
            case "Saturn" ->
            """
                     ,MMM8&&&.
                _...MMMMM88&&&&..._
             .::'''MMMMM88&&&&&&'''::.
            ::     MMMMM88&&&&&&     ::
            '::....MMMMM88&&&&&&....::'
               `''''MMMMM88&&&&''''`
                     'MMM8&&&'
""";
            case "Earth" ->
            """
                    _____
                ,-:` \\;',`'-, 
              .'-;_,;  ':-;_,'.
             /;   '/    ,  _`.-\
            | '`. (`     /` ` \\`|
            |:.  `\\`-.   \\_   / |
            |     (   `,  .`\\ ;'|
             \\     | .'     `-'/
              `.   ;/        .'
                `'-._____.-'`
""";
            case "Moon" ->
            """
                  _..._
                .'   `::.
               :       :::    
               :       :::
               `.     .::'
                 `-..:''
""";
            default -> "";
        };

        System.out.println("\n" + art + "\n");

        JavaCodeGenerator generator = new JavaCodeGenerator(className);
        String javaCode = generator.generate(ast);
        System.out.println(javaCode);
    }

    // @Test 
    // public void testHelloWorld0() {

    //     System.out.println("====== Test HelloWorld0.expresso ======");

    //     String input = """
    //         // HelloWorld0.expresso
    //         let x = 666
    //         let y = 10
    //         let f = z -> w -> 1
    //         print(f(x)(y)) 
    //     """;
        
    //     testExpressoProgram(input, "HelloWorld0");
    // }

    // @Test 
    // public void testHelloWorld0() {

    //     System.out.println("====== Test HelloWorld0.expresso ======");

    //     String input = """
    //         // HelloWorld0.expresso
    //         let x = 666
    //         print(x) // Expected 666 in console
    //         let y = 10
    //         print(y) // Expected 10 in console
    //         let f :(int->int) = z -> z ** 2 + 2*z + 1
    //         print(f(x) + f(y)) // expected 445010
    //     """;
        
    //     testExpressoProgram(input, "HelloWorld0");
    // }

    // @Test 
    // public void testHelloWorld1() {

    //     System.out.println("====== Test HelloWorld1.expresso ======");

    //     String input = "// HelloWorld1.expresso\n\n" +
    //                   "/*\n" +
    //                   "  As HelloWorld0 but with a Binary Function\n" +
    //                   "  @author hooNous\n" +
    //                   "  @since Oct 6th, 2025\n" +
    //                   "*/\n\n" +
    //                   "let x = 6\n" +
    //                   "print(x)\n" +
    //                   "let y = 3\n" +
    //                   "print(y)\n" +
    //                   "let f:((int, int) -> int) = (w, z) -> z ** w + w*z + 1\n" +
    //                   "print(f(x, y)) // Expected 748\n";
        
    //     testExpressoProgram(input, "HelloWorld1");
    // }

    // @Test 
    // public void testHelloWorld2() {

    //     System.out.println("====== Test HelloWorld2.expresso ======");

    //     String input = "// HelloWorld2.expresso\n\n" +
    //                   "/*\n" +
    //                   "  Boolean Logic\n" +
    //                   "  @author hooNous\n" +
    //                   "  @since Oct 6th, 2025\n" +
    //                   "*/\n\n" +
    //                   "let isZero :(int -> int) = x -> x ? 0 : 1\n" +
    //                   "let TRUE  = 1\n" +
    //                   "let FALSE = 0\n\n" +
    //                   "let isTrue :(int -> int) = x -> isZero(x) ? FALSE : TRUE\n\n" +
    //                   "let NOT :(int -> int) = x -> x ? 0 : 1\n\n" +
    //                   "let OR :((int, int) -> int) = (x, y) -> isTrue(x) ? TRUE : isTrue(y)\n\n" +
    //                   "let AND :((int, int) -> int) = (x, y) -> isTrue(x) ? isTrue(y) : FALSE\n\n" +
    //                   "let XOR :((int, int) -> int) = (x, y) -> AND(OR(x, y), NOT(AND(x, y)))\n\n" +
    //                   "print(XOR(TRUE, TRUE))   // Expected 0\n" +
    //                   "print(XOR(TRUE, FALSE))  // Expected 1\n" +
    //                   "print(XOR(FALSE, TRUE))  // Expected 1\n" +
    //                   "print(XOR(FALSE, FALSE)) // Expected 0\n";
        
    //     testExpressoProgram(input, "HelloWorld2");
    // }

    // @Test 
    // public void testHelloWorld4() {

    //     System.out.println("====== Test HelloWorld4.expresso ======");
    //     System.out.println("Tarea 13 - Tipos float-boolean-string-any");
                      
    //     String input = """
    //         let msg = "Hello \\"World\\""
    //         let x:float = 3.14
    //         let y = 666
    //         let b = true
    //         let s = "hello"
    //         print(x + 2.0 + y)
    //         print(s)
    //         print(b)
    //     """;
        
    //     testExpressoProgram(input, "HelloWorld4");
    // }
    
    // @Test 
    // public void testHelloWorld5() {

    //     System.out.println("====== Test HelloWorld5.expresso ======");
    //     System.out.println("Tarea 14 - fun");
                      
    //     String input = """
    //         fun fact(n:int):int = n ? n * fact(n - 1) : 1
    //         """;
            
    //     testExpressoProgram(input, "HelloWorld5");
    // }
    
    // @Test 
    // public void testHelloWorld6() {
    // System.out.println("====== Test HelloWorld6.expresso ======");
    
    // String input = "data nat = { Zero, S(n:nat) }\n" +
    //                "data list = { Nil, Cons(car:any, cdr:list) }\n" +
    //                "data gender = { Male, Female }\n" +
    //                "let x = 666\n" +
    //                "print(x)\n";
    
    // testExpressoProgram(input, "HelloWorld6");
    // }

    // @Test
    // public void testConstructorInvocation() {
    //     System.out.println("====== Test ConstructorInvocation.expresso ======");
    //     System.out.println("Tarea 17 - Soporte para el operador ^");

    //     String input = """
    //         data list = { Nil, Cons(car:any, cdr:list) }
    //         let x = ^Nil
    //         let y = ^Cons(666, ^Nil)
    //         print(y)
    //     """;

    //     testExpressoProgram(input, "ConstructorInvocation");
    // }

    // @Test
    // public void testComplexTypes() {
    //     System.out.println("====== Test ComplexTypes.expresso ======");
    //     System.out.println("Tarea 17 - Soporte para inferencia de tipos avanzada");

    //     String input = """
    //         data list = { Nil, Cons(car:any, cdr:list) }

    //         let empty:list = ^Nil 
    //         let numbers = ^Cons(1, empty)
    //         let first = numbers
    //         let another = ^Cons("hello", first)

    //         print(empty)
    //         print(numbers)
    //         print(first)
    //     """;

    //     testExpressoProgram(input, "ComplexTypes");
    // }

    // @Test
    // public void testMatchWith() {
    //     System.out.println("====== Test MatchWith.expresso ======");
    //     System.out.println("Tarea 18 - match ... with");

    //     String input = """

    //         data nat = { 
    //             Zero, 
    //             S(nat) 
    //         } 

    //         fun sum(x:nat, y:nat):nat = match x with 
    //                                 Zero -> y 
    //                                | S(z) -> S(sum(z, y))
    //                                | _ -> x
            
    //     """;

    //     testExpressoProgram(input, "MatchWith");
    // }

    // @Test
    // public void testArrowTuple() {
    //     System.out.println("====== Test ArrowTuple.expresso ======");
    //     System.out.println("Tarea 18 - Arrow y Tuple");

    //     String input = """
    //         //let arrow:(int -> int) = x -> x
    //         //let arrow2:((int, int, int) -> int) = (x, y, z) -> x + y
    //         //let lambda = x -> x
    //         //let lambda2 = (x, y, w) -> x
    //         //let lambda3 = x -> y -> 1
    //         //let lambda4 = (x:int) -> "1"
    //     """;

    //     testExpressoProgram(input, "ArrowTuple");
    // }

    //  @Test
    // public void testPrintAsNone() {
    //     System.out.println("====== Test printAsNone.expresso ======");
    //     System.out.println("Tarea 19 - print como expresion que retorna None");

    //     String input = """
    //         let x = none
    //         print(x)
    //         let y = print(42)
    //         print(y)
    //     """;
    //     testExpressoProgram(input, "HelloWorld7");
    // }
    // @Test
    // public void testBooleanLogic() {
    //     System.out.println("====== Test BooleanLogic.expresso (Tarea 21) ======");

    //     String input = """
            
    //         let a = 5
    //         let b = 10
    //         let t = true
    //         let f = false
            
    //         // === Operadores relacionales ===
    //         print(a < b)      // true
    //         print(a > b)      // false
    //         print(a <= 5)     // true
    //         print(a >= 5)     // true
    //         print(a == 5)     // true
    //         print(a != 0)     // true
            
    //         // === Operadores booleanos ===
    //         print(t && a < 10)   // true
    //         print(f || b > 5)    // true
    //         print("-- !t: expected false --")
    //         print(!t)            // false
    //         print(t || f)        // true
    //         print(t && f)        // false
            
    //         // === Ternario con int ===
    //         print(a != 0 ? "ok" : "error")   // ok
    //         print(0 ? 1 : 0)                 // 0
            
    //         // === Ternario con boolean ===
    //         print(t ? "yes" : "no")          // yes
    //         print(f ? "yes" : "no")          // no
            
    //         // === Combinacion ===
    //         print(a < b && t || a == 0)      // true
    //         print(!f && b >= 10)             // true
    //         print(a <= 5 ? b * 2 : b / 2)    // 20
    //         """;

    //     testExpressoProgram(input, "BooleanLogic");
    // }

    // @Test
    // public void testCasting() {
    //     System.out.println("====== Test Casting.expresso (Tarea 22) ======");
        
    //     String input = """
    //         // Casting examples
    //         let x = 2.5
    //         let y = true
    //         let s = "hola"
    //         let z = 3.7

    //         print(x:int)                    // 2
    //         print(s:string)                 // hola
    //         print(z:int)                    // 3
    //         print(y:boolean)                // true
            
    //         print(3**2*10 + x:int)          // 99
    //         print((x + 4):int)              // 3
    //         print((z + 0.5):int)            // 4

    //         let w = (x+z):int
    //         print(w)

    //         """;

    //     testExpressoProgram(input, "TestCasting");
    // }

    // @Test
    // public void testCastingWithType() {
    //     System.out.println("====== Test Casting with :: type ======");
        
    //     String input = """
    //         // Test con : y tipos
    //         let x = 2.5
            
    //         // 1. En asignación
    //         let a = x:int
    //         print(a)                    // Expected: 2
            
    //         // 2. En expresión simple  
    //         x:int
            
    //         // 3. En print
    //         print(x:int)               // Expected: 2
            
    //         // 4. En expresión aritmética
    //         print(x:int + 1)           // Expected: 3        
    //         """;
        
    //     testExpressoProgram(input, "TestCastingWithType");
    // }

    @Test
    public void testJupyter1() {
        System.out.println("\n====== Test Jupyter 1 ======");
        
        String input = """                
                /*
                Drafts for test cases and demo 11/06/2025
                loriacarlos@gmail.com
                Warnings: 
                * They could have some syntax issues (I haven't checked it)
                * They might be very much "involved" (beyond Earth?)
                
                In this file only TC1 and TC2 type examples
                
            */
            
            ////////////// TC1 /////////////////
            
            /*
            
                Repeats a string n-times using a recursive two-parameters fun
                Uses == 
                Potential Issue two-parameters type
                
                Define a Lambda (recognize type Function<Integer, String> and generate .apply)
                
            */
            
            fun fill(n:int, s:string):string = n == 0 ? "" : ( s + fill(n - 1, s) )
            
            print(fill(80, "-"))
            
            
            /*
                Potential issues:
                * Defines a lambda of type Function<Integer, String>
                * Generate line.apply
            */
            let line = n -> fill(n, "_") + "\n"
            print(line(80))
            
            /*
            * Defines a lambda returning 'void'; recognize type as a Consumer<Integer>
            * Generate .accept)
            */
            let print_line = (n:int) -> print( line(n) )
            
            // Call it. Potential Issue: generate as Cosumer<Integer> type and .accept 
            print_line(80) // print_line.accept(80)
            
            // Potential Issue: String concat "+"
            print("The only " + true + " answer to the meaning of life is: " + (1 + 666 / 666 + 20 * 2))
            print_line(80)
            
            """;
        
        testExpressoProgram(input, "Jupyter");
    }

    @Test
    public void testJupyter2() {
        System.out.println("\n====== Test Jupyter 2 ======");
        
        String input = """                
            /////////////// TC2 //////////////////
            
            print("*** Newton-Raphson TC2 **** ")
            
            let abs = x:float -> x >= 0 ? x : -x // Uses >= and unary -
            //  Potential issue: type is UnaryOperator<Double> and method is apply
            print("Test abs:" + (abs((-666):float) == abs((--666):float)) )
            
            let EPSILON =  1e-11 // Fully uppercased id. Issue floating-point using scientific notation
            print("EPSILON="  + EPSILON)
            
            let improve = (a:float, x:float) -> 0.5 * (x + a / x) // BinaryOperator<Double> .apply
            
            /* 
                Potential Issues: 
                Type is BiPredicate<Double>
                abs --> abs.apply
                
            */
            let converges = (a:float, x:float) -> abs(x ** 2 - a) < EPSILON
            
            
            /* 
                Potential Issues: 
                Type is BinaryOperator<Double>
                converges --> converges.test
                
            */
            
            let next = (a:float, x:float) -> converges(a, x) ? x : improve(a, x)
            
            /*
                Potential Issues:
                converges --> converges.test
                
            */
            
            fun sqrt_iterate(a:float, x0:float):float = converges(a, x0) ? x0 : sqrt_iterate(a, improve(a, x0))
            
            fun sqrt(a:float) = sqrt_iterate(a, a * 0.5)
            
            let test_sqrt = a:float -> a + " -sqrt-> " + sqrt(a)
            print(test_sqrt(4))
            print(sqrt(4) ** 2 + " ==? " + 4.0)
            print(sqrt(2)  + " ==? " + 1.4142135623730951)
            
            //////////////////////////////
            
            """;
        
        testExpressoProgram(input, "Jupyter");
    }

    @Test
    public void testSaturn() {
        System.out.println("\n====== Test Saturn ======");
        
        String input = """                
            data list = {
                Nil,
                Cons(car:any, cdr:list)
            }

            // let first = a:list -> match a with
            //                     Nil -> none 
            //                     | Cons(f, _) -> f


            fun length(a:list) = match a with
                                Nil -> 0
                                | Cons(_, r) -> 1 + length(r)

            fun copy(a:list) = match a with
                Nil -> a 
                Cons(f, r) -> ^Cons(f, copy(r))
                
            fun append(a:list, b:list) = match a with
                    Nil -> b
                | Cons(f, r) -> ^Cons(f, append(r, b))

                let append_as_lambda = (a:list, b:list) -> append(a, b)

                /*
                 Potential issues
                 * Type is BinaryOperator<list>
                 * Method is append_as_lambda.apply
                 
                */
                let double_list = a:list -> append_as_lambda(a, a)
                
                //////////////////////////////////////////////////
                let nil = ^Nil()
                
                let list_666 = ^Cons(666, nil)
                
                let list_777 = ^Cons(777, list_666)
                
                let list_888 = ^Cons(888, list_777)
                
                let myList = list_888
                
                
                // Tests
                
                print("myList=" + myList)
                
                print("myList first=" + first(myList)) 
                
                print("myList rest=" + rest(myList)) 
                
                print("myList length=" + length(myList)) 
                
                print("myList twice =" + double_list(myList))
                
                
                let myList_copy = copy(myList)
                
                print("myList copy =" + myList_copy)
                print("myList == myList_copy should be true?" + copy == myList_copy) 
            """;
        
        testExpressoProgram(input, "Saturn");
    }

}